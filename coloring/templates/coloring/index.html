{% load static %}

<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  	<title>P3 Coloring</title>

	<script type="text/javascript" src="{% static 'coloring/vendors/jquery/jquery-3.3.1.min.js' %}"></script>
	<script type="text/javascript" src="{% static 'coloring/vendors/paper/paper-full.min.js' %}"></script>

	<style type="text/css">
    html,
    body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      
    }

    /* Scale canvas with resize attribute to full size */
    canvas[resize] {
      width: 100%;
      height: 100%;
      position: relative;
      margin: auto;
    }

		.swatch {
			width: 24px;
			height: 24px;
			-moz-border-radius: 12px;
			-webkit-border-radius: 12px;
			border-radius: 12px; 
			margin: 3px;
		}
		#myCanvas {
			padding-left: 0;
		  padding-right: 0;
      margin: 0;
		  display: block;
		}
    


	</style>

	<script type="text/javascript" resize="true">
		window.onload = function() {
			var canvas = document.getElementById('myCanvas');
      
      
			// coloring page
			var mandala = {
				item: null,
				lastClicked: null,
				filePath: '/static/coloring/images/mandala-freepik.svg'
			};	
      
      // Metal gradient CSS from http://simurai.com/lab/2011/08/21/brushed-metal 
      // converted to svg with http://www.kmhcreative.com/downloads/CSS2SVG.htm
// 			var brushed = {
// 				item: null,
// 				lastClicked: null,
// 				filePath: '/static/coloring/images/brushed.svg'
// 			};	

			// color palette
			var cp = {
				history: ["#000000"], // black selected by default
				options: []
			}
      
      var _UNDO_STACK = [];
      var _ERASE_ACTIVE = false; 
      var selectedColor = "#000000";
      var selectedHueIndex = -1;
      var update_flag = false;
      var huesLst = [];
      var gradPath = null;

			// your custom interaction goes here!
			// you may replace everything
			function myCustomInteraction() {
        
        for (var i = 0, l = 299; i <= l; i++) {
          var brightness = .87;
	        var hue = (i / l) * 299;
	        var color = {
		      hue: hue,
		      saturation: 1,
		      brightness: brightness
	      };
	       huesLst.push(color);
       }
        selectedColor = huesLst[132];
        
        //Color gradient rectangle
        var gradWidth = paper.view.size.width;
        var gradHeight = paper.view.size.height;
				var gradTool = new paper.Tool();
        var gradRec = new paper.Rectangle(new paper.Point(gradWidth*.85, 0), new paper.Point(gradWidth*1.5, gradHeight));
        gradPath = new paper.Path.Rectangle(gradRec,gradWidth*0.2);
        gradPath.strokeColor =  "#4c4c4c";
        gradPath.strokeWidth = 3;
        gradPath.translate(0.5,0.5);
        
        gradPath.fillColor = {
          gradient: {//['red', 'orange', 'yellow', 'lime', 'blue', 'purple']
          stops: huesLst
        },
          origin: gradPath.bounds.topCenter,
          destination: gradPath.bounds.bottomCenter
        };
        
        //gradient mouse tool
				gradTool.onMouseDown = function (event) {
            var y = event.point.y;
				    var hit = mandala.item.hitTest(event.point, { tolerance: 5, fill: true });
				    if (hit) {
                if (_ERASE_ACTIVE) { //erase
                  _ERASE_ACTIVE = false;
                  var prevColor = hit.item.fillColor;
                  var currColor = "#ffffff";
                  var coords = [event.point.x, event.point.y];
				          hit.item.fillColor = currColor;//cp.history[cp.history.length - 1];
                  helperStoreAction(prevColor, currColor, coords, "erase");
                } else { //color
                  var prevColor = hit.item.fillColor;
                  var currColor = selectedColor;
                  var coords = [event.point.x, event.point.y];
				          hit.item.fillColor = currColor;//cp.history[cp.history.length - 1];
                  helperStoreAction(prevColor, currColor, coords, "color");
                }
				    } else {
              var hit = gradPath.hitTest(event.point, {tolerance: 10, fill: true });
              //var hit = raster.hitTest(event.point, { tolerance: 10, fill: true });
              //var lst = hit.color._components;
				      if (hit) {
                var yRatio = Math.round((event.point.y/paper.view.size.height)*huesLst.length);
                var hsvColorA = huesLst[yRatio];
                //console.log(hsvColorA, huesLst.length, yRatio);
                var colorObj = new paper.Color(hsvColorA);
                //var hexColor = helperRGBtoHex(HSVtoRGB(hsvColorA.hue, 1, .87), true);
                selectedColor = colorObj;
                selectedHueIndex = yRatio;
                update_flag = true;
                //console.log(colorObj);
                //var colorVal = myCanvas.getContext('2d').getImageData(1111, event.point.y, 1, 1).data;
                //console.log(y, hit);
                //var hexVal = helperRGBtoHex(hit.color, true);
				        //cp.history += hexVal;
				      }
            }
				}
        
 
        //Saturation rectangle
        var satWidth = paper.view.size.width;
        var satHeight = paper.view.size.height;
        var satRec = new paper.Rectangle(new paper.Point(satWidth*.90, 0), new paper.Point(satWidth*1.5,satHeight));
        var satBox = new paper.Path.Rectangle(satRec, satWidth*0.2);
        satBox.fillColor = "#b0b3b7"; 
        satBox.strokeColor =  "#4c4c4c";
        satBox.strokeWidth = 4;
        satBox.translate(0.5,0.5); //https://www.rgraph.net/canvas/docs/howto-get-crisp-lines-with-no-antialias.html
        
        //Undo Redo Box
        var R_Width = paper.view.size.width;
        var R_Height = paper.view.size.height;
        var R_Rec = new paper.Rectangle(new paper.Point(-R_Width*0.1,R_Height+R_Height*0.1), new paper.Point(R_Width*0.15, R_Height*0.9));
        var R_Path = new paper.Path.Rectangle(R_Rec,R_Width*0.1);
        R_Path.fillColor = "grey";
        var seperation_beginning = new paper.Point(R_Width*0.15/2, R_Height*0.905);
        var separation_end = new paper.Point(R_Width*0.075, R_Height);
        var separation_path = new paper.Path.Line(seperation_beginning, separation_end);
        separation_path.strokeColor = 'black';
      //  R_Path.insertAbove(gradPath);
        
        //Click tools for Undo and Redo buttons
    
        var undoTool = new paper.Tool();   
        undoTool.onMousedown = function (event) {
            var hitResult = R_Path.hitTest(event.point, {stroke: true, fill: true, tolerance: 3});
            console.log(hitResult);
            if (hitResult) {
              if (event.point.x >= R_Width*0.7) {
                console.log("it's to the left");
                HelperHandlerUndo();
              } else {
                HelperHandlerRedo();
                console.log("to the riiiight");
              }
            }
        }
        
        
        
        
        //Saturation Circles
        var satCircLst = []; //6
        var SAT_CONSTS = [1.0, .833, .667, .5, .333, .167];
        for (var i = 0, l = 5; i <= l; i++) {
	        var color = {
		      hue: selectedColor.hue,
		      saturation: SAT_CONSTS[i],
		      brightness: selectedColor.brightness
	      };
	       satCircLst.push(color);
       }
        
        var circWidth = paper.view.size.width;
        var circHeight = paper.view.size.height;
        var circStrokeWidth = 5;
        var cir_1 = new paper.Path.Circle(new paper.Point(circWidth*.97,circHeight*.87),circHeight*0.04);
        cir_1.fillColor = satCircLst[0];
        cir_1.strokeColor =  "#4c4c4c";
        cir_1.strokeWidth = circStrokeWidth;
        var cir_2 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.75),circHeight*0.04);
        cir_2.fillColor = satCircLst[1];
        cir_2.strokeColor =  "#4c4c4c";
        cir_2.strokeWidth = circStrokeWidth;
        var cir_3 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.63),circHeight*0.04);
        cir_3.fillColor = satCircLst[2];
        cir_3.strokeColor =  "#4c4c4c";
        cir_3.strokeWidth = circStrokeWidth;
        var cir_4 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.37),circHeight*0.04);
        cir_4.fillColor = satCircLst[3];
        cir_4.strokeColor =  "#4c4c4c";
        cir_4.strokeWidth = circStrokeWidth;
        var cir_5 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.25),circHeight*0.04);
        cir_5.fillColor = satCircLst[4];
        cir_5.strokeColor =  "#4c4c4c";
        cir_5.strokeWidth = circStrokeWidth;
        var cir_6 = new paper.Path.Circle(new paper.Point(circWidth*.97,circHeight*.13),circHeight*0.04);
        cir_6.fillColor = satCircLst[5];
        cir_6.strokeColor =  "#4c4c4c";
        cir_6.strokeWidth = circStrokeWidth;
        
        
        //Brightness slide bar
        //reference at http://vda-lab.github.io/2014/01/animation-and-slider-in-paperjs
        var VAL_CONSTS = [1.0, .8, .6, .5, .4, .2, .1];
        var valBarLst = [];
        for (var i = 0, l = 6; i <= l; i++) {
	        var color = {
		      hue: selectedColor.hue,
		      saturation: selectedColor.saturation,
		      brightness: VAL_CONSTS[i]
	      };
	       valBarLst.push(color);
       }
        var brightBar = new paper.Path();
        brightBar.add(new paper.Point(circWidth*0.88,circHeight*0.5));
        brightBar.add(new paper.Point(circWidth,circHeight*0.5));
        brightBar.strokeColor = 'lightgrey';
        brightBar.strokeWidth = circWidth*0.075;
        brightBar.strokeJoin = 'round';
        brightBar.strokeCap = 'round';
        brightBar.strokeColor = '#4c4c4c';
        
        brightBar.strokeColor = {
          gradient: {//['red', 'orange', 'yellow', 'lime', 'blue', 'purple']
          stops: valBarLst
        },
          origin: brightBar.bounds.bottomLeft,
          destination: brightBar.bounds.bottomRight
        };
        
        //Undo Redo Box
        
        
        //Brightness circle on bar
        var marker = new paper.Path.Circle({
             x:circWidth*0.9,
             y:circHeight*0.5,
           radius: circWidth*0.039,
         fillColor: selectedColor});
         marker.strokeColor = '#4b4b4b';
         marker.strokeWidth = 6;
        
        //Drag function to move the brightness circle
        //var brightTool = new paper.Tool();
        //gradTool.insertAbove();
        gradTool.onMouseDrag = function (event) {
            var hitResult = brightBar.hitTest(event.point, {stroke: true, tolerance: 0});
            if (hitResult) {
                if (event.point.x <= circWidth*0.88 || event.point.x >= circWidth) {
                  return;
                }
                marker.position.x = event.point.x;
                var brightIndex = Math.round( ((event.point.x/(circWidth*0.22))*10) - 40); //fixme
                selectedColor.brightness = valBarLst[brightIndex].brightness;
                //selectedColor.brightness = valBarLst[brightIndex].brightness;
                //marker.fillColor = selectedColor;
                paper.view.draw(); 
            }
        }
        
        gradTool.onMouseUp = function (event) {
          if (update_flag) {
            update_flag = false;
            
            //hue changes
            if (selectedHueIndex > 0 && selectedHueIndex < huesLst.length) {
              var midIndex = Math.round(huesLst.length/2);
              huesLst = arrayRotate(huesLst, selectedHueIndex-midIndex);
            }
            gradPath.fillColor = {
              gradient: {//['red', 'orange', 'yellow', 'lime', 'blue', 'purple']
              stops: huesLst
            },
              origin: gradPath.bounds.topCenter,
              destination: gradPath.bounds.bottomCenter
            };
            
            //saturation
            
            satCircLst = []; //6
            for (var i = 0, l = 5; i <= l; i++) {
	            var color = {
		              hue: selectedColor.hue,
		              saturation: VAL_CONSTS[i],
		              brightness: selectedColor.brightness
	            };
	         satCircLst.push(color);
           }
            
            cir_1.fillColor = satCircLst[0];
            cir_2.fillColor = satCircLst[1];
            cir_3.fillColor = satCircLst[2];
            cir_4.fillColor = satCircLst[3];
            cir_5.fillColor = satCircLst[4];
            cir_6.fillColor = satCircLst[5];
            
            
            //brightness
            //circle
            var valBarLst = [];
            for (var i = 0, l = 5; i <= l; i++) {
	            var color = {
		          hue: selectedColor.hue,
		          saturation: selectedColor.saturation,
		          brightness: VAL_CONSTS[i]
	          };
	          valBarLst.push(color);
            }
            marker.fillColor = selectedColor;
            
            brightBar.strokeColor = {
              gradient: {//['red', 'orange', 'yellow', 'lime', 'blue', 'purple']
              stops: valBarLst
            },
              origin: brightBar.bounds.bottomLeft,
              destination: brightBar.bounds.bottomRight
           };
            
            
            
            //at the end!!!
            paper.view.draw();
          }
        }
        
        
        
			}
      // Returns a brightness list of a certain hue given hueVal with constant saturation 1.
      function helperBrightnessColorsGenerator(hueVal) {
          var brightnessGradientLst = [];
          for (var i = 0, l = 5; i < l; i++) {
            var brightness = 1 - (i / l) * 1.5;
	          var color = {
		          hue: hueVal,
		          saturation: 1,
		          brightness: brightness
	        };
          brightnessGradientLst.push(color);
        }
        return brightnessGradientLst;
      }
      
      
      //Reference Comments:
      
      // See examples from https://www.webcomponents.org/element/@polymer/paper-slider
      // http://paperjs.org/tutorials/interaction/working-with-mouse-vectors/ drawing & vectors
      // https://www.smashingmagazine.com/2011/11/create-web-animations-with-paperjs/ creation of arbitrary curves as paths http://paperjs.org/examples/chain/
      // https://code.tutsplus.com/tutorials/getting-started-with-paperjs-user-interaction--cms-26509
      // https://code.tutsplus.com/tutorials/getting-started-with-paperjs-animation-and-images--cms-26530
      // consider curve background as scaled/transformed circle object
      // http://vda-lab.github.io/2014/01/animation-and-slider-in-paperjs 
      // https://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing?rq=1 clear canvas
      
      // Same as above except a list of saturation colors with constant brightness .87.
      // Saturation should not use a gradient for these colors see http://paperjs.org/examples/nyan-rainbow/
      function helperSaturationColorsGenerator(hueVal) {
          var saturationGradientLst = [];
          for (var i = 0, l = 5; i < l; i++) {
            var sat = 1 - (i / l) * 1.5;
	          var color = {
		          hue: hueVal,
		          saturation: sat,
		          brightness: .87
	        };
          saturationGradientLst.push(color);
        }
        return saturationGradientLst;
      }
      
      //Direction: true -> takes in a list of [r, g, b] values and returns a HEX string 
      //Direction: false -> or takes in HEX string and returns list of r, g, b, values.
      function helperRGBtoHex(lst, direction) {
        // toString-Parseint 16 referenced https://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hexadecimal-in-javascript
        if (direction) { //RGB to Hex
          var r = lst[0].toString(16);
          var g = lst[1].toString(16);
          var b = lst[2].toString(16);
          return "#" + r + g + b;
        } else { //Reverse (Hex to RGB)
          var hex = lst.substring(1); //ditch the #
          var r = hex.substring(0,2).parseInt(hex, 16); //first 2 hex
          var g = hex.substring(2,4).parseInt(hex, 16);
          var b = hex.substring(4,6).parseInt(hex, 16);
          return [r, g, b];
        }
      }
      //Takes in the value of H,S, and V, a direction(true/false), and returns a Hex string 
      function helperHSVtoHex(h,s,v,direction) {
           helperRGBtoHex(hsvToRgb(h, s, v),direction);
      }
      
      function hsvLstToRgb(lst) {
        return hsvToRgb(lst[0], lst[1], lst[2]);
      }
      
      //Converts HSV values [0,1] to RGB in [r,g,b] list format
     function HSVtoRGB(h, s, v) {
       //reference at https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately
          var r, g, b, i, f, p, q, t;
          if (arguments.length === 1) {
              s = h.s, v = h.v, h = h.h;
          }
          i = Math.floor(h * 6);
          f = h * 6 - i;
          p = v * (1 - s);
          q = v * (1 - f * s);
          t = v * (1 - (1 - f) * s);
          switch (i % 6) {
              case 0: r = v, g = t, b = p; break;
              case 1: r = q, g = v, b = p; break;
              case 2: r = p, g = v, b = t; break;
              case 3: r = p, g = q, b = v; break;
              case 4: r = t, g = p, b = v; break;
              case 5: r = v, g = p, b = q; break;
          }
          return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      
      //Returns the color of the pixel at coords X, Y in [r, g, b] format
      function helperColorAtPixel(x,y) {
        
        
        
        
      }
      
      
      //Takes in paperjs color object of the prev and next color for a location
      // at coords triggered by action of name and appends it to the end of stack _UNDO_STACK
      function helperStoreAction(prevColor, currColor, coords, name) {
        var currAction = {
				  prev: prevColor, 
          curr: currColor, 
          location: coords, //[x, y]
				  actionName: name //"color", "undo", "redo", "erase"
        }
        _UNDO_STACK += currAction;
      }
      
      function helperHandlerRedo() { //find last undo and redo it as redo action
        if (_UNDO_STACK.length > 0) {
          if (_UNDO_STACK[_UNDO_STACK.length-1].name == "undo") {
            helperHandlerUndo();
          }
        }
      }
      
      function helperHandlerUndo() {
        if (_UNDO_STACK.length == 0) {
          return;
        }
        var undoAction = _UNDO_STACK.pop();
        var hit = mandala.item.hitTest(undoAction.location, { tolerance: 5, fill: true });
        if (hit) {
          hit.item.fillColor = undoAction.prev;
          helperStoreAction(undoAction.curr, undoAction.prev, undoAction.location, "undo");
        }
      }
      
      //https://stackoverflow.com/questions/1985260/javascript-array-rotate/33451102#33451102 arrayrotate
      function arrayRotate(arr, count) {
        count -= arr.length * Math.floor(count / arr.length)
        arr.push.apply(arr, arr.splice(0, count))
        return arr
      }
     
      

			function init(custom){
				paper.setup(canvas);

				paper.project.importSVG(mandala.filePath, function(item) { 
					mandala.item = item._children["design-freepik"];
				    paper.project.insertLayer(0,mandala.item);

				    if (custom) {
           //   paper.project.importSVG(brushed.filePath);
				    	myCustomInteraction();	
				    }
					
				}); 
			}

			// To see your myGradientInteraction version visit: 
			// http://<your url>:8000/coloring/?type=gradient
			// To see your myCustomInteraction version visit: 
			// http://<your url>:8000/coloring/
			var url = window.location.href;
			if (url.indexOf("gradient") > -1) {
				init(false);
			} else {
				init(true);
			}
		}
	</script>
</head>
<body>	

	<canvas id="myCanvas" resize="true" data-paper-resize="true"></canvas>
 
</body>
</html>