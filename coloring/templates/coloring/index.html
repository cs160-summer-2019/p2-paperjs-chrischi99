{% load static %}

<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  	<title>P3 Coloring</title>

	<script type="text/javascript" src="{% static 'coloring/vendors/jquery/jquery-3.3.1.min.js' %}"></script>
	<script type="text/javascript" src="{% static 'coloring/vendors/paper/paper-full.min.js' %}"></script>

	<style type="text/css">
    html,
    body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      
    }

    /* Scale canvas with resize attribute to full size */
    canvas[resize] {
      width: 100%;
      height: 100%;
      position: absolute;
      margin: auto;
    }

		.swatch {
			width: 24px;
			height: 24px;
			-moz-border-radius: 12px;
			-webkit-border-radius: 12px;
			border-radius: 12px; 
			margin: 3px;
		}
		#myCanvas {
			padding-left: 0;
		  padding-right: 0;
      margin: 0;
		  display: block;
		}
    


	</style>

	<script type="text/javascript" resize="true">
		window.onload = function() {
			var canvas = document.getElementById('myCanvas');
      
			// coloring page
			var mandala = {
				item: null,
				lastClicked: null,
				filePath: '/static/coloring/images/mandala-freepik.svg'
			};	
      
      // Metal gradient CSS from http://simurai.com/lab/2011/08/21/brushed-metal 
      // converted to svg with http://www.kmhcreative.com/downloads/CSS2SVG.htm
// 			var brushed = {
// 				item: null,
// 				lastClicked: null,
// 				filePath: '/static/coloring/images/brushed.svg'
// 			};	

			// color palette
			var cp = {
				history: ["#000000"], // black selected by default
				options: []
			}
      
      var _UNDO_STACK = [];
      var _ERASE_ACTIVE = false; 

			// your custom interaction goes here!
			// you may replace everything
			function myCustomInteraction() {
        //var raster = new paper.Raster('/static/coloring/images/colorgradient.jpg');
        // http://paperjs.org/examples/radial-rainbows/ for rainbow gradiantion and color structure
        var huesLst = []; //299
        for (var i = 0, l = 299; i <= l; i++) {
          var brightness = .87;
	        var hue = (i / l) * 299;
	        var color = {
		      hue: hue,
		      saturation: 1,
		      brightness: brightness
	      };
	       huesLst.push(color);
       }
        var selectedColor = huesLst[132];
        //Color gradient rectangle
        var gradWidth = paper.view.size.width;
        var gradHeight = paper.view.size.height;
				var gradTool = new paper.Tool();
        var gradRec = new paper.Rectangle(new paper.Point(gradWidth*.85, 0), new paper.Point(gradWidth*1.5, gradHeight));
        var gradPath = new paper.Path.Rectangle(gradRec,gradWidth*0.2);
        gradPath.strokeColor =  "#4c4c4c";
        gradPath.strokeWidth = "5";
          
        gradPath.fillColor = {
          gradient: {//['red', 'orange', 'yellow', 'lime', 'blue', 'purple']
          stops: huesLst
        },
          origin: gradPath.bounds.topCenter,
          destination: gradPath.bounds.bottomCenter
        };
        
				gradTool.onMouseDown = function (event) {
            var y = event.point.y;
				    var hit = mandala.item.hitTest(event.point, { tolerance: 5, fill: true });
				    if (hit) {
                if (_ERASE_ACTIVE) { //erase
                  var prevColor = hit.item.fillColor;
                  var currColor = "#ffffff";
                  var coords = [event.point.x, event.point.y];
				          hit.item.fillColor = currColor;//cp.history[cp.history.length - 1];
                  helperStoreAction(prevColor, currColor, coords, "erase");
                } else { //color
                  var prevColor = hit.item.fillColor;
                  var currColor = selectedColor;
                  var coords = [event.point.x, event.point.y];
				          hit.item.fillColor = currColor;//cp.history[cp.history.length - 1];
                  helperStoreAction(prevColor, currColor, coords, "color");
                }
				    } else {
              var hit = gradPath.hitTest(event.point, {tolerance: 10, fill: true });
              //var hit = raster.hitTest(event.point, { tolerance: 10, fill: true });
              //var lst = hit.color._components;
				      if (hit) {
                var yRatio = (event.point.y/paper.view.size.height)*huesLst.length;
                var hsvColorA = huesLst[Math.round(yRatio)];
                console.log(hsvColorA, huesLst.length, yRatio);
                var colorObj = new paper.Color(hsvColorA);
                //var hexColor = helperRGBtoHex(HSVtoRGB(hsvColorA.hue, 1, .87), true);
                selectedColor = colorObj;
                console.log(colorObj);
                //var colorVal = myCanvas.getContext('2d').getImageData(1111, event.point.y, 1, 1).data;
                //console.log(y, hit);
                //var hexVal = helperRGBtoHex(hit.color, true);
				        //cp.history += hexVal;
				      }
            }
				}
 
        //Saturation rectangle
        var satWidth = paper.view.size.width;
        var satHeight = paper.view.size.height;
        var satRec = new paper.Rectangle(new paper.Point(satWidth*.90, 0), new paper.Point(satWidth*1.5,satHeight));
        var satBox = new paper.Path.Rectangle(satRec, satWidth*0.2);
        satBox.fillColor = "#b0b3b7"; 
        satBox.strokeColor =  "#4c4c4c";
        satBox.strokeWidth = "5";
        
        //Saturation Circles
        var satCircLst = []; //6
        var VAL_CONSTS = [1.0, .833, .667, .5, .333, .167];
        for (var i = 0, l = 5; i <= l; i++) {
	        var color = {
		      hue: selectedColor.hue,
		      saturation: VAL_CONSTS[i],
		      brightness: selectedColor.brightness
	      };
	       satCircLst.push(color);
       }
        
        var circWidth = paper.view.size.width;
        var circHeight = paper.view.size.height;
        var cir_1 = new paper.Path.Circle(new paper.Point(circWidth*.975,circHeight*.87),circHeight*0.04);
        cir_1.fillColor = satCircLst[0];
        cir_1.strokeColor =  "#4c4c4c";
        cir_1.strokeWidth = "5";
        var cir_2 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.75),circHeight*0.04);
        cir_2.fillColor = satCircLst[1];
        cir_2.strokeColor =  "#4c4c4c";
        cir_2.strokeWidth = "5";
        var cir_3 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.63),circHeight*0.04);
        cir_3.fillColor = satCircLst[2];
        cir_3.strokeColor =  "#4c4c4c";
        cir_3.strokeWidth = "5";
        var cir_4 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.37),circHeight*0.04);
        cir_4.fillColor = satCircLst[3];
        cir_4.strokeColor =  "#4c4c4c";
        cir_4.strokeWidth = "5";
        var cir_5 = new paper.Path.Circle(new paper.Point(circWidth*.95,circHeight*.25),circHeight*0.04);
        cir_5.fillColor = satCircLst[4];
        cir_5.strokeColor =  "#4c4c4c";
        cir_5.strokeWidth = "5";
        var cir_6 = new paper.Path.Circle(new paper.Point(circWidth*.975,circHeight*.13),circHeight*0.04);
        cir_6.fillColor = satCircLst[5];
        cir_6.strokeColor =  "#4c4c4c";
        cir_6.strokeWidth = "5";
        
        
        //Brightness slide bar
        //reference at http://vda-lab.github.io/2014/01/animation-and-slider-in-paperjs
        var valBarLst = [];
        for (var i = 0, l = 5; i <= l; i++) {
	        var color = {
		      hue: selectedColor.hue,
		      saturation: selectedColor.saturation,
		      brightness: VAL_CONSTS[i]
	      };
	       valBarLst.push(color);
       }
        var brightBar = new paper.Path();
        brightBar.add(new paper.Point(circWidth*0.75,circHeight*0.5));
        brightBar.add(new paper.Point(circWidth,circHeight*0.5));
        brightBar.strokeColor = 'lightgrey';
        brightBar.strokeWidth = circWidth*0.1;
        
        brightBar.strokeColor = {
          gradient: {//['red', 'orange', 'yellow', 'lime', 'blue', 'purple']
          stops: valBarLst
        },
          origin: brightBar.bounds.bottomLeft,
          destination: brightBar.bounds.bottomRight
        };
        
        //Undo Redo Box
        var U_RWidth = paper.view.size.width;
        var U_RHeight = paper.view.size.height;
        var U_RRec = new paper.Rectangle(new paper.Point(0, U_RHeight*0.2), new paper.Point(U_RWidth*0.32,U_RHeight*0.2));
        var U_RBox = new paper.Path.Rectangle(U_RRec, U_RWidth*0.2);
        U_RBox.fillColor = "blue"; 
        
        //Brightness circle on bar
        var marker = new paper.Path.Circle({
             x:circWidth*0.9,
             y:circHeight*0.5,
           radius: circWidth*0.05,
         fillColor: selectedColor})
        
        //Drag function to move the brightness circle
        var brightTool = new paper.Tool();
        gradTool.onMouseDrag = function (event) {
            var hitResult = brightBar.hitTest(event.point, {stroke: true, tolerance: 0});
            if (hitResult) {
                marker.position.x = event.point.x;
            }
        }
        
        
        
        
			}
      // Returns a brightness list of a certain hue given hueVal with constant saturation 1.
      function helperBrightnessColorsGenerator(hueVal) {
          var brightnessGradientLst = [];
          for (var i = 0, l = 5; i < l; i++) {
            var brightness = 1 - (i / l) * 1.5;
	          var color = {
		          hue: hueVal,
		          saturation: 1,
		          brightness: brightness
	        };
          brightnessGradientLst.push(color);
        }
        return brightnessGradientLst;
      }
      
      
      //Reference Comments:
      
      // See examples from https://www.webcomponents.org/element/@polymer/paper-slider
      // http://paperjs.org/tutorials/interaction/working-with-mouse-vectors/ drawing & vectors
      // https://www.smashingmagazine.com/2011/11/create-web-animations-with-paperjs/ creation of arbitrary curves as paths http://paperjs.org/examples/chain/
      // https://code.tutsplus.com/tutorials/getting-started-with-paperjs-user-interaction--cms-26509
      // https://code.tutsplus.com/tutorials/getting-started-with-paperjs-animation-and-images--cms-26530
      // consider curve background as scaled/transformed circle object
      // http://vda-lab.github.io/2014/01/animation-and-slider-in-paperjs 
      // https://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing?rq=1 clear canvas
      
      // Same as above except a list of saturation colors with constant brightness .87.
      // Saturation should not use a gradient for these colors see http://paperjs.org/examples/nyan-rainbow/
      function helperSaturationColorsGenerator(hueVal) {
          var saturationGradientLst = [];
          for (var i = 0, l = 5; i < l; i++) {
            var sat = 1 - (i / l) * 1.5;
	          var color = {
		          hue: hueVal,
		          saturation: sat,
		          brightness: .87
	        };
          saturationGradientLst.push(color);
        }
        return saturationGradientLst;
      }
      
      //Direction: true -> takes in a list of [r, g, b] values and returns a HEX string 
      //Direction: false -> or takes in HEX string and returns list of r, g, b, values.
      function helperRGBtoHex(lst, direction) {
        // toString-Parseint 16 referenced https://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hexadecimal-in-javascript
        if (direction) { //RGB to Hex
          var r = lst[0].toString(16);
          var g = lst[1].toString(16);
          var b = lst[2].toString(16);
          return "#" + r + g + b;
        } else { //Reverse (Hex to RGB)
          var hex = lst.substring(1); //ditch the #
          var r = hex.substring(0,2).parseInt(hex, 16); //first 2 hex
          var g = hex.substring(2,4).parseInt(hex, 16);
          var b = hex.substring(4,6).parseInt(hex, 16);
          return [r, g, b];
        }
      }
      //Takes in the value of H,S, and V, a direction(true/false), and returns a Hex string 
      function helperHSVtoHex(h,s,v,direction) {
           helperRGBtoHex(hsvToRgb(h, s, v),direction);
      }
      
      function hsvLstToRgb(lst) {
        return hsvToRgb(lst[0], lst[1], lst[2]);
      }
      
      //Converts HSV values [0,1] to RGB in [r,g,b] list format
     function HSVtoRGB(h, s, v) {
       //reference at https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately
          var r, g, b, i, f, p, q, t;
          if (arguments.length === 1) {
              s = h.s, v = h.v, h = h.h;
          }
          i = Math.floor(h * 6);
          f = h * 6 - i;
          p = v * (1 - s);
          q = v * (1 - f * s);
          t = v * (1 - (1 - f) * s);
          switch (i % 6) {
              case 0: r = v, g = t, b = p; break;
              case 1: r = q, g = v, b = p; break;
              case 2: r = p, g = v, b = t; break;
              case 3: r = p, g = q, b = v; break;
              case 4: r = t, g = p, b = v; break;
              case 5: r = v, g = p, b = q; break;
          }
          return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      
      //Returns the color of the pixel at coords X, Y in [r, g, b] format
      function helperColorAtPixel(x,y) {
        
        
        
        
      }
      
      
      //Takes in paperjs color object of the prev and next color for a location
      // at coords triggered by action of name and appends it to the end of stack _UNDO_STACK
      function helperStoreAction(prevColor, currColor, coords, name) {
        var currAction = {
				  prev: prevColor, 
          curr: currColor, 
          location: coords, //[x, y]
				  actionName: name //"color", "undo", "redo", "erase"
        }
        _UNDO_STACK += currAction;
      }
      
      function helperHandlerRedo() { //find last undo and redo it as redo action
        if (_UNDO_STACK.length > 0) {
          if (_UNDO_STACK[_UNDO_STACK.length-1].name == "undo") {
            helperHandlerUndo();
          }
        }
      }
      
      function helperHandlerUndo() {
        if (_UNDO_STACK.length == 0) {
          return;
        }
        var undoAction = _UNDO_STACK.pop();
        var hit = mandala.item.hitTest(undoAction.location, { tolerance: 5, fill: true });
        if (hit) {
          hit.item.fillColor = undoAction.prev;
          helperStoreAction(undoAction.curr, undoAction.prev, undoAction.location, "undo");
        }
      }
     
      

			function init(custom){
				paper.setup(canvas);

				paper.project.importSVG(mandala.filePath, function(item) { 
					mandala.item = item._children["design-freepik"];
				    paper.project.insertLayer(0,mandala.item);

				    if (custom) {
           //   paper.project.importSVG(brushed.filePath);
				    	myCustomInteraction();	
				    }
					
				}); 
			}

			// To see your myGradientInteraction version visit: 
			// http://<your url>:8000/coloring/?type=gradient
			// To see your myCustomInteraction version visit: 
			// http://<your url>:8000/coloring/
			var url = window.location.href;
			if (url.indexOf("gradient") > -1) {
				init(false);
			} else {
				init(true);
			}
		}
	</script>
</head>
<body>	

	<canvas id="myCanvas" resize="true" data-paper-resize="true"></canvas>
 
</body>
</html>